(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

var _extend = _interopRequireDefault(require("./modules/extend"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// TODO: При генерации scoped стилей сделать определение нескольких селекторов,
// записанных через запятую, и вставлять перед каждый атрибут scoped
var CSSinJSON =
/*#__PURE__*/
function () {
  function CSSinJSON(options) {
    _classCallCheck(this, CSSinJSON);

    this.elem_selector = options.elem; // Селектор элемента

    this.elem = document.querySelector(options.elem); // Сам элемент

    this.style_obj = options.style; // Объект стилей

    this.scoped = options.scoped; // Флаг изоляции стилей

    this.Extend = _extend.default; // Плагин объединения объектов

    this.scopedId = ''; // Здесь будет сгенерированный id для изоляции стилей

    this.style_string = ''; // Здесь будут сгенерированные стили в виде строки
    // Точка входа

    this.init();
  } // Генератор рандомного числа


  _createClass(CSSinJSON, [{
    key: "rand",
    value: function rand(min, max) {
      var rand = Math.floor(min + Math.random() * (max + 1 - min));
      return rand;
    } // Генератор id для изоляции в диапазоне символов a-z

  }, {
    key: "scopedIdGenerate",
    value: function scopedIdGenerate() {
      var id = '';

      for (var i = 0; i < 10; i++) {
        id += String.fromCharCode(this.rand(97, 122));
      }

      return id;
    } // TODO: разобраться с этим методом
    // Метод расширения стилей, пока работает не правильно

  }, {
    key: "extend",
    value: function extend(obj1, obj2) {
      this.style_obj = this.Extend(obj1, obj2);
      this.style_string = this.jsonToStyle(this.style_obj, this.scopedId);
      this.updateStyleInject(this.style_string, this.scopedId);
      return this.style_string;
    } // Вставка новых стилей в готовый элемент style

  }, {
    key: "updateStyleInject",
    value: function updateStyleInject(style_content, scoped) {
      var stl = document.querySelector("#".concat(scoped));
      stl.textContent = style_content;
    } // Создание нового элемента style и заполнение его атрибутами и стилями

  }, {
    key: "styleInject",
    value: function styleInject(style_content, elem, class_name, scoped) {
      var stl = document.createElement('style');
      stl.id = scoped;
      stl.className = class_name;
      stl.textContent = style_content;
      elem.appendChild(stl);
    } // Генерирует строковые стили для одного селектора

  }, {
    key: "objToStyle",
    value: function objToStyle(selector, obj, scoped) {
      var scoped_selector = scoped !== '' ? "[data-scoped=".concat(scoped, "]") : '';
      var style = '';

      for (var prop in obj) {
        style += "\n    ".concat(prop, ": ").concat(obj[prop], ";");
      }

      if (selector === this.elem_selector) {
        return "".concat(selector).concat(scoped_selector, " {").concat(style, "\n}");
      }

      return "".concat(scoped_selector, " ").concat(selector, " {").concat(style, "\n}");
    } // Генерирует полные стили по входящему объекту

  }, {
    key: "jsonToStyle",
    value: function jsonToStyle(json) {
      var scoped = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var style = '';

      for (var selector in json) {
        style += this.objToStyle(selector, json[selector], scoped) + '\n\n';
      }

      return style;
    }
  }, {
    key: "init",
    value: function init() {
      // Если нужно, сгенерировать id для изоляции стилей
      if (this.scoped) {
        this.scopedId = this.scopedIdGenerate();
        this.elem.dataset.scoped = this.scopedId;
      } // Сгенерировать строку стилей из полученного объекта


      this.style_string = this.jsonToStyle(this.style_obj, this.scopedId); // Вставить сгенерированные стили на страницу

      this.styleInject(this.style_string, document.head, 'CSSinJSON_style', this.scopedId);
    }
  }]);

  return CSSinJSON;
}();

window.CSSinJSON = CSSinJSON;

},{"./modules/extend":2}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extend;

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*Функция из jQuery для объединения объектов
 * var newObj = extend(obj_1, obj_2);
 *
 * Для рекурсивного объединения
 * var newObj = extend(true, obj_1, obj_2);
 *
 * Работа функции изменяет первый объект obj_1
 * newObj === obj_1
 */
function extend() {
  var options,
      name,
      src,
      copy,
      copyIsArray,
      clone,
      target = arguments[0] || {},
      i = 1,
      length = arguments.length,
      deep = false; // Handle a deep copy situation

  if (typeof target === "boolean") {
    deep = target; // Skip the boolean and the target

    target = arguments[i] || {};
    i++;
  } // Handle case when target is a string or something (possible in deep copy)


  if (_typeof(target) !== "object" && !isFunction(target)) {
    target = {};
  } // Extend jQuery itself if only one argument is passed


  if (i === length) {
    target = this;
    i--;
  }

  for (; i < length; i++) {
    // Only deal with non-null/undefined values
    if ((options = arguments[i]) != null) {
      // Extend the base object
      for (name in options) {
        src = target[name];
        copy = options[name]; // Prevent never-ending loop

        if (target === copy) {
          continue;
        } // Recurse if we're merging plain objects or arrays


        if (deep && copy && (isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
          if (copyIsArray) {
            copyIsArray = false;
            clone = src && Array.isArray(src) ? src : [];
          } else {
            clone = src && isPlainObject(src) ? src : {};
          } // Never move original objects, clone them


          target[name] = extend(deep, clone, copy); // Don't bring in undefined values
        } else if (copy !== undefined) {
          target[name] = copy;
        }
      }
    }
  }

  function isPlainObject(obj) {
    var proto, Ctor; // Detect obvious negatives
    // Use toString instead of jQuery.type to catch host objects

    if (!obj || toString.call(obj) !== "[object Object]") {
      return false;
    }

    proto = getProto(obj); // Objects with no prototype (e.g., `Object.create( null )`) are plain

    if (!proto) {
      return true;
    } // Objects with prototype are plain iff they were constructed by a global Object function


    Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
    return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;

    function getProto(obj) {
      obj = obj || {};
      return obj.getPrototypeOf;
    }

    function class2type() {
      return {};
    }

    function hasOwn(class2type) {
      return class2type.hasOwnProperty;
    }

    function fnToString(hasOwn) {
      return hasOwn.toString;
    }
  } // Return the modified object


  return target;
}

;

},{}]},{},[1])

//# sourceMappingURL=maps/css-in-json.min.js.map
