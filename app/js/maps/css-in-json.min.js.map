{"version":3,"sources":["node_modules/browser-pack/_prelude.js","app/js/css-in-json.js","app/js/modules/extend.js"],"names":["r","e","n","t","o","i","f","c","require","u","a","Error","code","p","exports","call","length","1","module","_extend","CSSinJSON","options","arguments","undefined","_classCallCheck","this","elems_selector","scoped_elems","scoped","style_obj","style","Extend","default","scopedId","style_string","init","scopedElem","min","max","rand","Math","floor","random","camel","replace","toLowerCase","selector","_this","_typeof","forEach","element","push","document","querySelectorAll","elem","dataset","id","String","fromCharCode","obj1","obj2","jsonToStyle","updateStyleInject","style_content","querySelector","concat","textContent","class_name","stl","createElement","className","appendChild","_this2","regex","selector_arr","split","filter","search","scoped_selector","new_selector","scoped_elem","slice","obj","prop","camelToKebab","scopedSelectorGenerate","json","objToStyle","scopedIdGenerate","console","log","findScopedElems","styleInject","head","window","extend","name","src","copy","copyIsArray","clone","target","deep","isFunction","isPlainObject","Array","isArray","proto","Ctor","toString","getProto","hasOwn","constructor","fnToString","ObjectFunctionString","getPrototypeOf","class2type","hasOwnProperty"],"mappings":"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","file":"../css-in-json.min.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","import Extend from './modules/extend';\r\n\r\n// TODO: При генерации scoped стилей сделать определение нескольких селекторов,\r\n// записанных через запятую, и вставлять перед каждый атрибут scoped\r\n\r\nclass CSSinJSON {\r\n    constructor(options = {}) {\r\n        this.elems_selector = []; // Селекторы элементов\r\n        this.scoped_elems = []; // Сами элементы\r\n        this.scoped = false; // Флаг изоляции стилей\r\n\r\n        // this.elem_selector = options.elem; // Селектор элемента\r\n        // this.elem = document.querySelector(options.elem); // Сам элемент\r\n        // this.scoped = options.scoped; // Флаг изоляции стилей\r\n\r\n        this.style_obj = options.style; // Объект стилей\r\n\r\n\r\n        this.Extend = Extend; // Плагин объединения объектов\r\n\r\n        this.scopedId = ''; // Здесь будет сгенерированный id для изоляции стилей\r\n        this.style_string = ''; // Здесь будут сгенерированные стили в виде строки\r\n\r\n\r\n        // Точка входа\r\n        this.init(options.scopedElem);\r\n    }\r\n\r\n    // Генератор рандомного числа\r\n    rand(min, max) {\r\n        let rand = Math.floor(min + Math.random() * (max + 1 - min));\r\n        return rand;\r\n    }\r\n\r\n    // Конвертер camelCase в cebab-case\r\n    camelToKebab(camel) {\r\n        return camel.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\r\n    }\r\n\r\n    findScopedElems(selector) {\r\n        if (typeof selector === 'object') {\r\n            selector.forEach(element => {\r\n                this.elems_selector.push(element);\r\n                let elems_of_selector = document.querySelectorAll(element);\r\n                elems_of_selector.forEach(elem => {\r\n                    elem.dataset.scoped = this.scopedId;\r\n                    this.scoped_elems.push(elem);\r\n                })\r\n            });\r\n        } else if (typeof selector === 'string') {\r\n            this.elems_selector.push(selector);\r\n            this.scoped_elems = document.querySelectorAll(selector);\r\n            this.scoped_elems.forEach(elem => {\r\n                elem.dataset.scoped = this.scopedId;\r\n            })\r\n        }\r\n\r\n        this.scoped = (this.scoped_elems.length > 0) ? true : false;\r\n    }\r\n\r\n    // Генератор id для изоляции в диапазоне символов a-z\r\n    scopedIdGenerate() {\r\n        let id = '';\r\n        for (let i = 0; i < 10; i++) {\r\n            id += String.fromCharCode(this.rand(97, 122));\r\n        }\r\n\r\n        return id;\r\n    }\r\n\r\n    // TODO: разобраться с этим методом\r\n    // Метод расширения стилей, пока работает не правильно\r\n    extend(obj1, obj2) {\r\n        this.style_obj = this.Extend(obj1, obj2);\r\n        this.style_string = this.jsonToStyle(this.style_obj, this.scopedId);\r\n        this.updateStyleInject(this.style_string, this.scopedId);\r\n\r\n        return this.style_string;\r\n    }\r\n\r\n    // Вставка новых стилей в готовый элемент style\r\n    updateStyleInject(style_content, scoped) {\r\n        let stl = document.querySelector(`#${scoped}`);\r\n        stl.textContent = style_content;\r\n    }\r\n\r\n    // Создание нового элемента style и заполнение его атрибутами и стилями\r\n    styleInject(style_content, elem, class_name, scoped) {\r\n        let stl = document.createElement('style');\r\n        stl.id = scoped;\r\n        stl.className = class_name;\r\n        stl.textContent = style_content;\r\n        elem.appendChild(stl);\r\n    }\r\n\r\n    // TODO: Улучшить поиск базового селектора\r\n    // Метод для генерации селекторов с атрибутом scoped.\r\n    // Разбирает несколько селекторов, указанных через запятую\r\n    scopedSelectorGenerate(selector) {\r\n        let regex = /(,\\s*\\n*\\t*)/gm;\r\n        let selector_arr = selector.split(regex).filter(selector => (selector.search(regex) === -1) ? true : false);\r\n        let scoped_selector = `[data-scoped=${this.scopedId}]`;\r\n        let new_selector = '';\r\n\r\n        // Цикл по селекторам, указанным в стилях через запятую\r\n        selector_arr.forEach(selector => {\r\n            // Если надо генерировать изолированные стили\r\n            if (this.scoped) {\r\n\r\n                // Цикл по каждому базовому селектору\r\n                this.elems_selector.forEach(scoped_elem => {\r\n                    // Если селектор соответствует базовому селектору scoped\r\n                    if (scoped_elem === selector) {\r\n                        new_selector += `${selector}${scoped_selector},\\n`;\r\n                        // Если селектор НЕ соответствует базовому селектору scoped\r\n                    } else {\r\n                        new_selector += `${scoped_selector} ${selector},\\n`;\r\n                    }\r\n                });\r\n\r\n                // Если НЕ надо генерировать изолированные стили\r\n            } else {\r\n                new_selector += `${selector},\\n`;\r\n            }\r\n        })\r\n\r\n        return new_selector.slice(0, -2);\r\n    }\r\n\r\n    // Генерирует строковые стили для одного селектора\r\n    objToStyle(selector, obj) {\r\n        let scoped_selector = (this.scoped) ? `[data-scoped=${this.scopedId}]` : '';\r\n        let style = '';\r\n        for (let prop in obj) {\r\n            style += `\\n    ${this.camelToKebab(prop)}: ${obj[prop]};`\r\n        }\r\n\r\n        return `${this.scopedSelectorGenerate(selector)} {${style}\\n}`;\r\n\r\n\r\n    }\r\n\r\n    // // Генерирует строковые стили для одного селектора\r\n    // objToStyle2(selector, obj) {\r\n    //     let scoped_selector = (this.scoped) ? `[data-scoped=${this.scopedId}]` : '';\r\n    //     let style = '';\r\n    //     for (let prop in obj) {\r\n    //         style += `\\n    ${this.camelToKebab(prop)}: ${obj[prop]};`\r\n    //     }\r\n\r\n    //     let base_elem = false;\r\n    //     this.elems_selector.forEach(scoped_elem => {\r\n    //         if (scoped_elem === selector) {\r\n    //             base_elem = true;\r\n    //         }\r\n    //     });\r\n\r\n    //     if (base_elem) {\r\n    //         return `${selector}${scoped_selector} {${style}\\n}`\r\n    //     } else {\r\n    //         return `${scoped_selector} ${selector} {${style}\\n}`\r\n    //     }\r\n\r\n\r\n    // }\r\n\r\n    // Генерирует полные стили по входящему объекту\r\n    jsonToStyle(json) {\r\n        let style = '';\r\n        for (let selector in json) {\r\n            style += this.objToStyle(selector, json[selector]) + '\\n\\n';\r\n        }\r\n\r\n        return style;\r\n    }\r\n\r\n\r\n    init(selector) {\r\n        this.scopedId = this.scopedIdGenerate();\r\n\r\n        console.log('selector: ', selector);\r\n\r\n        this.findScopedElems(selector);\r\n\r\n\r\n        // Сгенерировать строку стилей из полученного объекта\r\n        this.style_string = this.jsonToStyle(this.style_obj);\r\n\r\n        // Вставить сгенерированные стили на страницу\r\n        this.styleInject(this.style_string, document.head, 'CSSinJSON_style', this.scopedId);\r\n    }\r\n}\r\n\r\nwindow.CSSinJSON = CSSinJSON;","/*Функция из jQuery для объединения объектов\r\n * var newObj = extend(obj_1, obj_2);\r\n *\r\n * Для рекурсивного объединения\r\n * var newObj = extend(true, obj_1, obj_2);\r\n *\r\n * Работа функции изменяет первый объект obj_1\r\n * newObj === obj_1\r\n */\r\n\r\n\r\nexport default function extend() {\r\n    var options, name, src, copy, copyIsArray, clone,\r\n        target = arguments[0] || {},\r\n        i = 1,\r\n        length = arguments.length,\r\n        deep = false;\r\n    // Handle a deep copy situation\r\n    if (typeof target === \"boolean\") {\r\n        deep = target;\r\n        // Skip the boolean and the target\r\n        target = arguments[i] || {};\r\n        i++;\r\n    }\r\n    // Handle case when target is a string or something (possible in deep copy)\r\n    if (typeof target !== \"object\" && !isFunction(target)) {\r\n        target = {};\r\n    }\r\n    // Extend jQuery itself if only one argument is passed\r\n    if (i === length) {\r\n        target = this;\r\n        i--;\r\n    }\r\n    for (; i < length; i++) {\r\n        // Only deal with non-null/undefined values\r\n        if ((options = arguments[i]) != null) {\r\n            // Extend the base object\r\n            for (name in options) {\r\n                src = target[name];\r\n                copy = options[name];\r\n                // Prevent never-ending loop\r\n                if (target === copy) {\r\n                    continue;\r\n                }\r\n                // Recurse if we're merging plain objects or arrays\r\n                if (deep && copy && (isPlainObject(copy) ||\r\n                        (copyIsArray = Array.isArray(copy)))) {\r\n                    if (copyIsArray) {\r\n                        copyIsArray = false;\r\n                        clone = src && Array.isArray(src) ? src : [];\r\n                    } else {\r\n                        clone = src && isPlainObject(src) ? src : {};\r\n                    }\r\n                    // Never move original objects, clone them\r\n                    target[name] = extend(deep, clone, copy);\r\n                    // Don't bring in undefined values\r\n                } else if (copy !== undefined) {\r\n                    target[name] = copy;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function isPlainObject(obj) {\r\n        var proto, Ctor;\r\n        // Detect obvious negatives\r\n        // Use toString instead of jQuery.type to catch host objects\r\n        if (!obj || toString.call(obj) !== \"[object Object]\") {\r\n            return false;\r\n        }\r\n        proto = getProto(obj);\r\n        // Objects with no prototype (e.g., `Object.create( null )`) are plain\r\n        if (!proto) {\r\n            return true;\r\n        }\r\n        // Objects with prototype are plain iff they were constructed by a global Object function\r\n        Ctor = hasOwn.call(proto, \"constructor\") && proto.constructor;\r\n        return typeof Ctor === \"function\" && fnToString.call(Ctor) === ObjectFunctionString;\r\n\r\n        function getProto(obj) {\r\n            obj = obj || {};\r\n            return obj.getPrototypeOf;\r\n        }\r\n\r\n        function class2type() {\r\n            return {};\r\n        }\r\n\r\n        function hasOwn(class2type) {\r\n            return class2type.hasOwnProperty;\r\n        }\r\n\r\n        function fnToString(hasOwn) {\r\n            return hasOwn.toString;\r\n        }\r\n    }\r\n\r\n    // Return the modified object\r\n    return target;\r\n};"]}